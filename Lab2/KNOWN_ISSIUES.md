Вот список имющихся на данный момент недочетов и их исправления

1)В текущей реализации реализовано  РВ -> НКА -> ДКА, хотя по заданию необходимо РВ -> ДКА

Возможное исправление:
Для случая РВ->ДКА с учетом групп (follow position algorithm) : при построении и обходе АСТ для узлов типа GROUP и GROUP_REF мы заполняем наши мн-ва N, F, L, FP таким образом, словно GROUP И GROUP_REF это a-node. Также, поскольку у узла GROP есть ребенок (то, что захватывает группа), необходимо для ребенка выполнить тот же самый алгоритм, что и для узла дерева (соответственно необходимо начать нумерацию a-node-ов с нуля и предварительно добавить в конец той части РВ, которая захватывается группой, символ конца '$'). Нам лишь остается выполнить алгоритм с теми изменениями, что когда мы встретились с узлом типа GROUP, то помимо обработки его как обычного a-node, рекурсивно выполнить этот алгоритм и для ребенка узла, добавив получившийся автомат в массив ДКА

2)Как работает в общем алгоритм. Что происходит в циклах в FindAll и его недостаток у текущего метода с точки зрения производительности.

Суть работы алгоритма компиляции: парсинг РВ (проходимся по строке и строим АСТ, увеличивая при этом счетчик); проверка корректности РВ (обход АСТ с проверкой на повторяющиеся группы и некорректные обращения к группам); построение НКА (обход АСТ - для каждого типа узла свой алгоритм построения части НКА (создание переходов и состояний)); НКА -> ДКА (преобразование состояний и переходов с использованием ε-замыкания (избавляемся от ε-переходов и нескольких переходов из одного состояния по одинаковому символу, обеспечивая детерминированность)); минимизация ДКА (делим все состояния на 2 группы и на основе алфавита итеративно разбиваем эти группы - если для всех состояний и всех символов из определенной группы нет перехода в состояния одной и той же группы)
FindAll: внешний цикл перебирает все возможные начальные позиции в строке, внутренний цикл для каждой начальной позиции пытается найти минимальную длину подстроки, которая соответствует регулярному выражению. В худшем случае O(n²). Для улучшения производительности можно не создавать подстроку (substr) и использовать std::string_view или просто передавать индексы. Также можно запоминать позицию начала и конца совпадения при использовании Match, чтобы избежать избыточного вызова Match (например: если мы не смогли перейти из начального состояния, то нет смысла проверять подстроку дальше во внутреннем цикле, поэтому можно переходить к следующей итерации внешнего цикла)

Правильнее идея в том, что если найдено совпадение, в следующий раз начинать поиск после окончания совпадения, так чаще всего реализуется findall, опция с перекрывающимся поиском возможна, и где-то даёт новый функционал, но в целом медленнее.
Также копировать строки тоже не корректно.

3)Функция Regex::Match получилась довольно сложной. Также коде две почти идентичные реализации Match.

Для того, чтобы избежать дублирование кода, можно было бы внутри метода Match, принимающего и само РВ, после вызова метода Compile вызывать метод Match, принимающий только строку для проверки. Для упрощения понимания следовало бы добавить ёмкие комментарии в некоторых местах и добавить несколько небольших функций, каждая из которых будет отвечать только за одну задачу (Например: ProcessSymbol и ProcessGroup для обработки одной итерации автомата, Finalize для проверки оставшихся переходов по группам, чтобы достичь принимающего состояния)

4)TEST_CASE("yippee") не проходит

Данный тест не проходил из-за строк CHECK(regex.Match("\t", data)) и CHECK(regex.Match("\b", data)), поскольку внутри метода ComplementRegex использовалась следующая проверка для определения алфавита: if (isprint(i)). Таким образом, мы добавляли переходы только по печатным символам. Если изменить проверку на: (isprint(i) | | isspace(i) | | iscntrl(i)), то мы будем учитывать все пробельные (' ', '\t', '\n', '\v', '\f', '\r') и управляющие (\a, \b, \r, \n, \t, \v, \f, и т.д.) символы

В целом такая проверка не нужна. При complement-е по должны принимается все возможные символы алфавита