# Система управления клеточным роботом в шестиугольном лабиринте

Разработать систему для управления клеточным роботом, осуществляющим передвижение по клеточному лабиринту. Клетка лабиринта имеет форму правильного шестиугольника.

Робот может передвинуться в соседнюю клетку в случае отсутствия в ней препятствия; препятствиями могут являться как стены, так и коробки, которые робот может передвигать. Робот может одновременно передвигать несколько коробок, но не более определённой массы (определяется средой выполнения).

---

## 1. Формальный язык для описания действий клеточного робота

Язык должен поддерживать следующие литералы, операторы и предложения:

- **Знаковые целочисленные литералы** в десятичном и шестнадцатеричном формате (INT). Размер числа неограничен. Определены специальные литералы: бесконечность `INF`, минус бесконечности `-INF` и неопределённое значение `NAN`.

- **Логические литералы**: `T[RUE]`, `F[ALSE]`, `U[NDEF]` (BOOL). Логические константы и выражения преобразуются в знаковые целочисленные значения как `1` и `0` соответственно; целочисленные значения преобразуются в логические: `0` – false, всё остальное – true.

- **Тип описатель клетки** `CELL = {EMPTY, WALL, BOX, EXIT, UNDEF}`; преобразование в логический тип: если состояние клетки `EXIT` или `EMPTY` — `TRUE`, `BOX` или `WALL` — `FALSE`, `UNDEF` — `UNDEF`. Преобразование в `INT` и обратно: `EMPTY ↔ 0`, `WALL ↔ INF`, `BOX ↔ вес коробки`, `EXIT ↔ -INF`, `UNDEF ↔ NAN`.

- **VAR** — переменная произвольного типа.

- **Объявление переменных и констант** в форматах:

    - Переменные могут предварительно объявляться, но это не обязательно;
    - Тип переменной определяется при объявлении и первой инициализации и может изменяться при присваивании значения другого типа;
    - Переменные являются одномерными массивами произвольной размерности;
    - Элемент массива может содержать ссылку на другую переменную;
    - Размерность определяется при инициализации и может быть расширена.

- **Формат опционального объявления:**

VAR|INT|BOOL|CELL <имя переменной 1>[, имя переменной 2, …]


- Применяется строгая типизация: если преобразование не определено и типы не совпадают, возникает семантическая ошибка.

- **Обращение к переменной:**

<имя переменной>[(индекс)]


- Индекс — любое целое число (включая отрицательные);
- Если индекс не указан, обращение происходит к переменной целиком;
- В разных элементах массива могут храниться значения разных типов;
- Обращение к неопределённой переменной или по неопределённому индексу не является ошибкой — возвращается неопределённое значение.

- **Операторы присваивания:**

- Присваивание элементу массива:

  ```
  <имя переменной>(индекс) := <выражение>
  ```

- Присваивание массиву целиком:

  ```
  <имя переменной> := <имя переменной>
  ```

- **Бинарные и унарные арифметические операторы:**

- `<арифметическое выражение 1> + <арифметическое выражение 2>`
- `<арифметическое выражение 1> - <арифметическое выражение 2>`
- `- <арифметическое выражение>`
- `#<имя переменной>` — сумма всех элементов массива

- **Бинарные и унарные логические операторы:**

- `<логическое выражение 1> ^ <логическое выражение 2>` (оператор XOR)

- **Операторы сравнения с возвращаемым логическим значением:**

- `<арифметическое выражение> < <арифметическое выражение>`
- `<арифметическое выражение> > <арифметическое выражение>`
- `<выражение> = <выражение>`

- **Циклический оператор:**

while <логическое выражение> do <предложения языка 1> [finish <предложения языка 2>] done


- Цикл выполняет тело, пока логическое выражение истинно;
- При ложном значении управление переходит к блоку `finish` (если он есть), который выполняется один раз;
- При неопределённом значении выход из цикла без захода в `finish`.

- **Условный оператор:**

if <логическое выражение> do <предложения языка 1> done [eldef do <предложения языка 2> done] [elund do <предложения языка 3> done];


- Если логическое выражение истинно — выполняется блок 1;
- Если ложно — выполняется блок 2 (если он есть);
- Если неопределено — выполняется блок 3 (если он есть).

- **Операторы управления роботом:**

- Перемещение вперёд / назад:

  ```
  forward <арифметическое выражение> / backward <арифметическое выражение>
  ```

    - Робот проверяет возможность выполнения команды;
    - Если возможно — перемещается и возвращает `true`;
    - Если нет — не перемещается и возвращает `false`;
    - При вероятности неудачи (зависит от расстояния и веса груза) робот останавливается и возвращает `UNDEF`.

- Повороты на 60 градусов:

  ```
  left / right
  ```

    - Робот не может повернуться, если вес груза превышает пороговое значение.

- Загрузка / выгрузка коробок:

  ```
  load <арифметическое выражение> / drop <арифметическое выражение>
  ```

    - Робот может загружать бесконечное количество коробок;
    - Поворачиваться может только при весе груза ниже порога;
    - Коробка помещается в слот, определяемый выражением;
    - Операторы возвращают `true` при успешной операции, `false`, если слот/клетка заняты, `undef` — если в клетке/слоте нет коробки.

- **Операторы осмотра окрестностей:**

- `look` — возвращает расстояние до ближайшего препятствия в направлении движения.
- `test` — возвращает тип ближайшего препятствия.

- **Описатель функции:**

function [<имя функции>] (параметр) do <предложения языка> done


- Возврат и передача значений через параметр функции;
- Функции имеют изолированную область видимости;
- Функции могут объявляться внутри других функций;
- Точка входа — функция с именем `main`;
- Прерывание функции возможно оператором `return`.

- **Вызов процедуры:**

<имя функции> (параметр)


- Язык регистронезависим. Предложения завершаются символом перевода строки.

---

## 2. Интерпретатор языка

- Разработать интерпретатор языка с помощью `flex` и `bison`.
- Обеспечить контроль корректности применения языковых конструкций (например, запрет инкремента/декремента константы).
- Грамматика должна быть по возможности однозначной.

---

## 3. Программа поиска выхода из лабиринта

- Написать программу на разработанном языке, управляющую роботом для поиска выхода из лабиринта.
- Описание лабиринта и начальное положение робота задаются в текстовом файле.
